//
// This file is part of Smoothie.
//
// Copyright (C) 2013-2015 Flowy Apps GmbH <hello@flowyapps.com>
//
// enhancements to support node-require
// Copyright (c) 2016, Simon Y Blackwell, AnyWhichWay All rights reserved.
//
// Smoothie is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// Smoothie is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
// details.You should have received a copy of the GNU Lesser General Public
// License along with Smoothie.  If not, see <http://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////////////////////////
// INFO Standalone require()
//      This is a stripped down standalone version of Smoothie's require
//      function. If you also like to have a 'bootloader', which gives you some
//      nice hooks to execute code on different loading states of the document
//      and keeps your JavaScript completely separate from your HTML, we
//      recommend to load smoothie.js from the library's root directory.
// NOTE The load parameter points to the function, which prepares the
//      environment for each module and runs its code. Scroll down to the end of
//      the file to see the function definition.
// NOTE Mozilla still sets the wrong fileName porperty for errors that occur
//      inside an eval call (even with sourceURL). However, the stack
//      contains the correct source, so it can be used to re-threw the error
//      with the correct fileName property.
// NOTE Re-threwing a new error object will mess up the stack trace and the
//      column number.
// INFO Current module descriptors
//      pwd[0] contains the descriptor of the currently loaded module,
//      pwd[1] contains the descriptor its parent module and so on.
// INFO Path parser
// NOTE Older browsers don't support the URL interface, therefore we use an
//      anchor element as parser in that case. Thes breaks web worker support,
//      but we don't care since these browser also don't support web workers.
// INFO Module cache
// NOTE Contains getter functions for the exports objects of all the loaded
//      modules. The getter for the module 'mymod' is name '$name' to prevent
//      collisions with predefined object properties (see note below).
//      As long as a module has not been loaded the getter is either undefined
//      or contains the module code as a function (in case the module has been
//      pre-loaded in a bundle).
// NOTE IE8 supports defineProperty only for DOM objects, therfore we use a
//      HTMLDivElement as cache in that case. This breaks web worker support,
//      but we don't care since IE8 has no web workers at all.
// INFO Send lock
// NOTE Sending the request causes the event loop to continue. Therefore
//      pending AJAX load events for the same url might be executed before
//      the synchronous onLoad is called. This should be no problem, but in
//      Chrome the responseText of the sneaked in load events will be empty.
//      Therefore we have to lock the loading while executing send().   
// INFO Smoothie options
//      The values can be set by defining a object called Smoothie. The
//      Smoothe object has to be defined before this script here is loaded
//      and changing the values in the Smoothie object will have no effect
//      afterwards!
// NOTE Parse module root paths
// NOTE Add preloaded modules to cache
// NOTE Add module overrides to cache
// INFO Module getter
//      Takes a module identifier, resolves it and gets the module code via an
//      AJAX request from the module URI. If this was successful the code and
//      some environment variables are passed to the load function. The return
//      value is the module's `exports` object. If the cache already
//      contains an object for the module id, this object is returned directly.
// NOTE If a callback function has been passed, the AJAX request is asynchronous
//      and the mpdule exports are passed to the callback function after the
//      module has been loaded.
// INFO Module resolver
//      Takes a module identifier and resolves it to a module id and URI. Both
//      values are returned as a module descriptor, which can be passed to
//      `fetch` to load a module.
// INFO Exporting require to global scope
// INFO Module loader
//      Takes the module descriptor, the global variables and the module code,
//      sets up the module envirinment, defines the module getter in the cache
//      and evaluates the module code. If module is a bundle the code of the
//      pre-loaded modules will be stored in the cache afterwards.
// NOTE This functions is defined as an anonymous function, which is passed as
//      a parameter to the closure above to provide a clean environment (only
//      global variables, module and exports) for the loaded module. This is
//      also the reason why `source`, `pwd` & `cache` are not named parameters.
// NOTE If we would strict use mode here, the evaluated code would be forced to be
//      in strict mode, too.
!function(e){"use strict"
function r(i,u,f){function d(){if(4==g.readyState){if(200!=g.status)throw new o("unable to load "+p.id+" ("+g.status+" "+g.statusText+")")
if(a[v])return console.warn("module locked: "+p.id),void(u&&setTimeout(d,0))
if(!s[v]){var r=f?f(g.responseText):g.responseText
e(p,s,n,"function(){\n"+r+"\n}")}u&&u(s[v])}}if(i instanceof Array){for(var c=new Array,m=i.length,h=0;h<i.length;h++)!function(e,t){c.push(r(e,u&&function(e){c[t]=e,0==--m&&u(c)},f))}(i[h],h)
return c}f=void 0!==f?f:l
var p=t(i),v="$"+p.id
if(s[v])return"string"==typeof s[v]&&e(p,s,n,s[v]),u&&setTimeout(function(){u(s[v])},0),s[v]
var g=new XMLHttpRequest
return u&&(g[null===g.onload?"onload":"onreadystatechange"]=d),g.open("GET",p.uri,!!u),a[v]=a[v]++||1,g.send(),a[v]--,!u&&d(),s[v]}function t(e){var r=e.match(/^(?:([^:\/]+):)?(\.\.?)?\/?((?:.*\/)?)([^\.]+)?(\..*)?$/),t=(n[0]?n[0].id:"").match(/^(?:([^:\/]+):)?(.*\/|)[^\/]*$/),s=r[2]?f[t[1]?parseInt(t[1]):0]:f[r[1]?parseInt(r[1]):0]
i.href=(r[2]?s+t[2]+r[2]+"/":s)+r[3]+(r[4]?r[4]:"index")
var u=i.href+(r[5]?r[5]:"")
if(u.substr(0,s.length)!=s)throw new o("Relative identifier outside of module root")
var a=(r[1]?r[1]+":":"0:")+i.href.substr(s.length)
return{id:a,uri:u}}var o=function(e,r,t){this.name="SmoothieError",this.message=e}
o.prototype=Object.create(Error.prototype),"string"==typeof(new Error).fileName&&self.addEventListener("error",function(e){if(e.error instanceof Error){if(n[0])throw e.preventDefault(),new e.error.constructor(e.error.message,n[0].uri,e.error.lineNumber)
var r=e.error.stack.match(/^[^\n@]*@([^\n]+):\d+:\d+/)
if(null===r)console.warn("Smoothie: unable to read file name from stack")
else if(e.error.fileName!=r[1])throw e.preventDefault(),new e.error.constructor(e.error.message,r[1],e.error.lineNumber)}},!1)
var n=Array(),i=URL?new URL(location.href):document.createElement("A")
try{var s=new Object
Object.defineProperty(s,"foo",{value:"bar",configurable:!0}),delete s.foo}catch(u){console.warn("Falling back to DOM workaround for defineProperty: "+u),s=document.createElement("DIV")}for(var a=new Object,f=self.Smoothie&&void 0!==self.Smoothie.requirePath?self.Smoothie.requirePath.slice(0):["./"],l=self.Smoothie&&void 0!==self.Smoothie.requireCompiler?self.Smoothie.requireCompiler:null,d=[location.origin,location.href.substr(0,location.href.lastIndexOf("/")+1)],c=0;c<f.length;c++)i.href=("."==f[c][0]?d[1]:d[0])+f[c],f[c]=i.href
for(var m in self.Smoothie&&self.Smoothie.requirePreloaded)s["$"+t(m).id]=self.Smoothie.requirePreloaded[m].toString()
for(var m in self.Smoothie&&self.Smoothie.requireOverrides)s["$"+t(m).id]=self.Smoothie.requireOverrides[m]
if(void 0!==self.require)throw new o("'require' already defined in global scope")
try{Object.defineProperty(self,"require",{value:r}),Object.defineProperty(self.require,"resolve",{value:t}),Object.defineProperty(self.require,"path",{get:function(){return f.slice(0)}})}catch(u){self.require=r,self.require.resolve=t,self.require.path=f.slice(0)}}(function(module){var global=self,exports=new Object
if(Object.defineProperty(module,"exports",{get:function(){return exports},set:function(e){exports=e}}),arguments[2].unshift(module),Object.defineProperty(arguments[1],"$"+module.id,{get:function(){return exports}}),arguments[3]="("+arguments[3]+")();\n//# sourceURL="+module.uri,eval(arguments[3]),"string"!=typeof module.id)for(id in module)arguments[1]["$"+require.resolve(id).id]=module[id].toString()
arguments[2].shift()})
