<html>
<head>
<script src="../joqular.js" type="text/javascript"></script>
</head>
<body>

<script type="text/javascript">
"use strict";
function getName() { return 'Simon'; }
getName.deferred=true;
Object = JOQULAR.enhance(Object,{enhancePrimitives:true,enhanceArray:true,enhanceSet:true,enhanceDate:true,index:true});
var TimeSpan = JOQULAR.TimeSpan;
var d1 = new Date();
var d2 = new Date();
d2.setTime(d1.getTime()+(24*60*60));
var d3 = new Date();
d3.setTime(d2.getTime()+(24*60*60));
var du4 = new TimeSpan();
du4.startingTime = d3.getTime();
var o = {name: 'Simon', number: 1, array1: [1,2,3], array2: [4,5,6], child: {name: 'Simon', child: {name: 'Simon'}}, sibling: {child: {name: 'Simon'}}, duration0: new TimeSpan(d1), duration1: new TimeSpan(d1,d2), duration2: new TimeSpan(d2,d3), duration3: new TimeSpan(d3), duration4: du4};
console.log(o.joqularMatch({name: 'Simon'}));
console.log(o.joqularMatch({name: isNaN}));
console.log(o.joqularMatch({name: {$: isNaN, eq: 'Simon'}}));
console.log(o.joqularMatch({name: getName}));
console.log(o.joqularMatch({name: {eq: getName}}));
console.log(o.joqularMatch({name: {eq: {'.': 'name'}}}));
console.log(o.joqularMatch({name: {eq: {'/': 'name'}}})); // /field.name.name
console.log(o.joqularMatch({child: {name: {eq: 'Simon'}}}));
console.log(o.joqularMatch({child: {name: {eq: {'..sibling.child': 'name'}}}}));
console.log(o.joqularMatch({child: {name: {eq: {'/': 'name'}}}}));
console.log(o.joqularMatch({child: {name: {eq: {'/sibling.child': 'name'}}}}));
console.log(o.joqularMatch({name: {eq: 'Simon'}}));
console.log(o.joqularMatch({name: {neq: 'Joe'}}));
console.log(o.joqularMatch({number: 1}));
console.log(o.joqularMatch({number: {eq: 1}}));
console.log(o.joqularMatch({number: {neq: 0}}));
console.log(o.joqularMatch({number: {gt: 0}}));
console.log(o.joqularMatch({number: {gte: 0}}));
console.log(o.joqularMatch({number: {gte: 1}}));
console.log(o.joqularMatch({number: {lt: 2}}));
console.log(o.joqularMatch({number: {lte: 1}}));
console.log(o.joqularMatch({number: {lte: 2}}));
console.log(o.joqularMatch({array1: [1,2,3]}));
console.log(o.joqularMatch({array1: [4,5,6]})); // null expected
console.log(o.joqularMatch({array1: {eq: [1,2,3]}}));
console.log(o.joqularMatch({array1: {neq: [0,1,2]}}));
console.log(o.joqularMatch({array1: {intersects: [0,1,2]}}));
console.log(o.joqularMatch({array1: {intersects: {'.': 'array1'}}}));
console.log(o.joqularMatch({array1: {disjoint: [4,5,6]}}));
console.log(o.joqularMatch({array1: {disjoint: {'.': 'array2'}}}));
console.log(o.joqularMatch({array1: {coincident: [1,2,3]}}));
console.log(o.joqularMatch({array1: {coincident: {'.': 'array1'}}}));
console.log(o.joqularMatch({duration1: {intersects: {startingTime: d1, endingTime:d2}}}));
console.log(o.joqularMatch({duration1: {intersects: {'.': 'duration2'}}}));
console.log(o.joqularMatch({duration1: {intersects: {'.': 'duration3'}}})); // null expected
console.log(o.joqularMatch({duration1: {adjacentOrBefore: {'.': 'duration2'}}}));
console.log(o.joqularMatch({duration2: {adjacentOrAfter: {'.': 'duration1'}}}));
console.log(o.joqularMatch({duration2: {adjacent: {'.': 'duration4'}}}));
console.log(o.joqularMatch({duration4: {coincident: {startingTime: du4.startingTime, endingTime:Infinity}}}));

function TestObject(id,array) {
	this.id = id;
	this.array = array || [];
}
function AsyncObject(id,array) {
	this.id = id;
}
function PromiseObject(id,array) {
	this.id = id;
}
function Person(name) {
	this.name = name;
}
Person.prototype = new Object();
Person.prototype.getName = function() { return this.name; }

Person = JOQULAR.createIndex(Person);
TestObject = JOQULAR.createIndex(TestObject,true);
AsyncObject = JOQULAR.createIndex(AsyncObject,function(instance) { console.log(instance); })
PromiseObject = JOQULAR.createIndex(PromiseObject,true);

var s1 = new Person('Simon');
//Object.joqularIndex(s1);
console.log(Person.joqularFind({name: 'Simon'}));
console.log(Person.joqularFind({name: {eq: 'Simon', instanceof: Person}}));
s1.name = "Joe";

var t1 = new TestObject(10);
var t2 = new TestObject(20,new Array(1,2,3));
var t3 = new TestObject(30);
console.log(TestObject.joqularFind({id: 20}));
console.log(TestObject.joqularFind({id: {lt: 20}}));
console.log(TestObject.joqularFind({id: {lte: 20}}));
console.log(TestObject.joqularFind({id: {eq: 20}}));
console.log(TestObject.joqularFind({id: {neq: 20}}));
console.log(TestObject.joqularFind({id: {gte: 20}}));
console.log(TestObject.joqularFind({id: {gt: 20}}));
console.log(TestObject.joqularFind({array: {contains: 1}}));
t1.id = -1;

var a1 = new AsyncObject(10);
var p1 = new PromiseObject(10).then(function(instance) { console.log(instance); });
var r1 = AsyncObject.joqularFind({id: 10},function(results) { console.log(results); });
var r2 = PromiseObject.joqularFind({id: 10},true);
r2.then(function(results) { console.log(results); });

console.time("generate");
var objects = [];
var numobj = 50000;
console.time("index");
for(let i=0;i<numobj;i++) {
	let p = new Person(i);
	objects.push(p);
	objects.push(new TestObject(i));
}
console.timeEnd("generate");
console.time("linearFind middle");
for(let i=0;i<objects.length;i++) {
	if(objects[i].name===numobj/2) {
		console.log(objects[i]);
		break;
	}
}
console.timeEnd("linearFind middle");

console.time("linearFind end");
for(let i=0;i<objects.length;i++) {
	if(objects[i].name===numobj-1) {
		console.log(objects[i]);
		break;
	}
}
console.timeEnd("linearFind end");

Person.joqularFind(null,true).then(function(results) { 
	console.timeEnd("index");
	console.time("joqularFind middle");
	console.log(Person.joqularFind({name: numobj/2}));
	console.timeEnd("joqularFind middle");
	console.time("joqularFind middle after first cache");
	console.log(Person.joqularFind({name: numobj/2}));
	console.timeEnd("joqularFind middle after first cache");
	console.time("joqularFind end");
	console.log(Person.joqularFind({name: numobj-1}));
	console.timeEnd("joqularFind end");	
});



/*
console.time("joqularFind test");
console.log(Person.joqularFind({name: {lt: 5}}));
console.timeEnd("joqularFind test");
console.time("linearFind test");
var found = [];
for(var i=0;i<objects.length;i++) {
	if(objects[i].name<5) {
		found.push(objects[1]);
	}
}
console.log(found);
console.timeEnd("linearFind test");
*/
// {name: {'@': [new Date(),'Simon',new Duration().atLeast(),'Joe']}}

function Relation(specification) {
	var f = function(config) {
		var me = this;
		for(var key in config) {
		    if(typeof(config[key])!=="function") {
				if(cons.specification.objects[key]) {
					if(cons.specification.objects[key].kind) {
						if(config[key] instanceof cons.specification.objects[key].kind) {
							me[key] = config[key];
						} else {
							throw new Error(cons.specification.name + "." + key + " must be an instance of " + cons.specification.objects[key].kind);
						}
					}
				} else {
					me[key] = config[key];
				}
			}
		}
		me.implications = [];
		cons.implications.forEach(function(implication) {
			var implications = implication.mapping["function"](me);
			implications.forEach(function(implied) {
				var relation = new implication.relation(implied);
				if(implication.mapping.cascade.updates) {
					Object.observe(me,function(changes) {
						changes.forEach(function(change) {
							if(typeof(implication.mapping.cascade.updates)==="function") {
								implication.mapping.cascade.updates.call(relation,change);
							} else {
								implication.mapping["function"](me);
							}
						});
					},["update"]);
				}
				me.implications.push(relation);
			});
		});
		return me;
	}
	var cons = new Function("f","return function " + specification.name + "() { return f.call(this,arguments[0]); }")(f);
	cons.specification = specification;
	cons.implications = [];
	cons.implies = function(relation,mapping) {
		cons.implications.push({relation:relation,mapping:mapping});
		return cons;
	}
	cons.prototype = new Object();
	return cons;
}
var Marriage = Relation({name: "Marriage", objects: {husband:{cardinality: 1, kind: Person}, wife:{cardinality: 1, kind: Person}}});
var Spouse = Relation({name: "Spouse", objects: {partner1:{cardinality: 1, kind: Person}, partner2:{cardinality: 1, kind: Person}}});
var Children = Relation({name: "parent", objects: {parent: {cardinality: 2, kind: Person}, children: {cardinality: Infinity, kind: Person}}});
Marriage = JOQULAR.createIndex(Marriage);
Spouse = JOQULAR.createIndex(Spouse);
Marriage.implies(Spouse,{cascade: {
	deletes:true,
	updates: function(change) {
			if(this.partner1 === change.oldValue) {
				this.partner1 = change.object[change.name];
			} else if(this.partner2 === change.oldValue) {
				this.partner2 = change.object[change.name];
			}
		}
	}, "function": function(marriage) { return [{partner1: marriage.husband, partner2: marriage.wife},{partner1: marriage.wife, partner2: marriage.husband}] }});

var Simon = new Person('Simon');
var Juliana = new Person('Juliana');
var m1 = new Marriage({husband: Simon, wife: Juliana});
var m2 = new Marriage({husband: {}, wife: Juliana});
</script>

</body>
</html>